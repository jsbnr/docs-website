---
title: Observability as code
tags:
  - Observability as code
  - Automation
  - Workflow
  - Implementation guide
# redirects:
#   - /docs/new-relic-solutions/observability-maturity/
---

## Overview [#overview]
Observability as code (OaC) is a term used to describe the method of writing code that uses management APIâ€™s to configure New Relic. It leverages the use of automation workflows and provisioning tools to enable New Relic configuration to be deployed reliably at scale.

This guide provides guidance on your approach to Observability as code, offers good practice advice and is supported by a collection of reference examples to enable you to build and maintain your New Relic platform at scale.

## Why adopt Observability as Code [#why-observability-as-code]
As your New Relic estate evolves its scale and complexity increases and if not held in check can become difficult to maintain via the user interface. Adopting Observbility as Code practices will enable you to successfully scale and maintain your New Relic deployment. It helps accelerate adoption whilst at the same time encourages longer term stability and affords opportunities for better governance.

Here are some of the benefits of adopting Observabiity as Code for your New Relic deployment:

> QQQQ? How to order these?

<CollapserGroup>

    <Collapser
        id="oac-benefits-1"
        title="Repeatable, replicable"
    >
        Managing New Relic resources through code means that they can easily be repeated, scaled and updated in bulk. Leveraging a modular approach with provisioning tools like terraform allow packaged sets of resources such as dashboards, alerts and workloads to be quickly and easily shared and deployed, accelerating startup time and improving organization wide standards.    
    </Collapser>

    <Collapser
        id="oac-benefits-2"
        title="Reduced toil"
    >
        The toil of creating and maintaining New Relic resources managed through code is significantly less than manually managing them via the user interface, especially when working at scale. Whilst the interface lends itself well to discovery and testing, changes to code-managed resources can be bulk applied vastly reducing the time administering the resources. One common approach is to develop alerts and dashboards within the user interface and then when considered mature enough they are then migrated to code-managed resources.    
    </Collapser>

    <Collapser
        id="oac-benefits-3"
        title="Documentation and context"
    >
        The huge variety of resources that can be configured in New Relic may make it difficult to understand just by looking at a single resource why it has been created or configured as it has. Configuration via code allows for commenting and documentation to be included that helps explain why certain choices may have been made, when and by whom.    
    </Collapser>

    <Collapser
        id="oac-benefits-4"
        title="Auditable history"
    >
        Whilst it is possible to understand who made changes to New Relic resources via the NRAuditEvent event type this does not provide much background as to *why* the changes were made, what their previous state was or who approved the changes to be made. Managing resources via code in tandem with an automated approval based provisioning workflow allows for much clearer visibility of changes and improved governance whilst also providing methods for rollback and recovery.
    
    </Collapser>

    <Collapser
        id="oac-benefits-5"
        title="Security"
    >
        Observability as code allows for stricter controls over the use of API keys for managing New Relic resources. Security is improved by reducing the number of API keys in circulation and ensuring adequate governance is in place  concerning their creation and dissementation. Dissuading users from using their own keys, especially within automated worfklows,  means the surface area for a key breach or unintended corruption is reduced.  
    </Collapser>

    <Collapser
        id="oac-benefits-6"
        title="Efficient, delta changes"
    >
        Provisioning tools like Terraform make it possible to make delta changes to existing resources. This makes updates quick and efficient as only resources attributes that need changing are changed, with minimal resource destruction and re-creation. This is important as it ensures that the GUIDs of resources such as dashboards and alerts are not changed on update.    
    </Collapser>

    <Collapser
        id="oac-benefits-7"
        title="React to external stimuli"
    >
        Combining Observability as code with automated workflows allows for New Relic resources to be created and amended as a result of external stimuli such as application deployments, infrastructure events or any other data input. For example, you could automatically generate dashboards and alerts that compare key golden signal metrics between code version releases at deployment time.    
    </Collapser>

    <Collapser
        id="oac-benefits-8"
        title="Contextual ownership and packaging"
    >
        Managing resources in code allows for related resources to be managed together. It's easier to comprehend and manage them in one place, in code, than it is when distributed across the user interface. For instance, this allows different teams to manage, view and maintain the resources within their sphere of influence and not have to hunt for  resources they manage.    
    </Collapser>

   <Collapser
        id="oac-benefits-9"
        title="Disaster recovery"
    >
        Occasionally mistakes happen, the wrong resource is updated or deleted. Recovering from these situations with manual resource management is difficult as it's not easy to know what existed before or even if the resource has been changed or lost at all. Observability as code helps protect from these issues by ensuring that any resource can be recreated or reset to the expected configuration. It also creates an opportunity to proactively detect configuration drift.    
    </Collapser>

   <Collapser
        id="oac-benefits-10"
        title="Speed of deployment"
    >
        Observability as code accelerates the speed of deployment by allowing for a common set of resources to be easily shared amongst teams and used to bootstrap observability tooling. This is particularly evident in microservice architectures where similar application deployment architectures benefit from cookie-cutter module-based New Relic resources. Creating reusable centrally managed modules also helps to standardize common approaches to observability tooling.    
    </Collapser>

  
</CollapserGroup>   

## Assesing Maturity [#assessing-maturity]

> TBC - Thinking caps on, need a decent  way to evalaute maturity

It's a familiar pattern for entities from different environments to be instrumented and report to different New Relic accounts. For instance, your production stack might report to a production account, and non-production to another. The ratio of resources provisioned with code compared to those manually provisioned should be higher the closer an environment is to production. Some customers choose to restrict manual access to production environments entirely, enforcing auditable, managed code changes to production configurations.

![Percentage of code driven configuration increases with environment maturity](./images/oac-env-maturity.png "Environment maturity")
<figcaption>
  This diagram illustrates how the percentage of resources managed with code may increase toward production environments.
</figcaption>
