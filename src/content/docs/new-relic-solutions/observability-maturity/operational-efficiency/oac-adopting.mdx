---
title: Adopting Observability as Code
tags:
  - Adopting Observability as Code
  - Automation
  - Workflow
  - Implementation guide
# redirects:
#   - /docs/new-relic-solutions/observability-maturity/
---
You have decided to adopt Observability as Code with New Relic but are unsure how to get started or you want to avoid common dead ends and bear traps. Here we provide a number of good practice guides, advice and reference examples to help you confidently adopt Observability as Code.

## Deployment design [#deployment-design]
TBC

### Team based resource management  [#team-based-resources]
TBC

### API keys [#api-keys]
Managing resources using the NerdGRaph graphQL API or via provisioning tools such as terraform requires the use of [user API keys](/docs/apis/intro-apis/new-relic-api-keys/). New Relic API keys are generated against a user and inherit the permissions of that user. 

### Service Accounts
Creating API keys against real human users can cause issues to automated pipelines. For example if that user's permissions change as part of a team move or the user leaves the organization an automation pipeline that relies upon it could fail. 

Consider creating "service account" users that are managed by a central management team that are specifically created for  automation purposes. These teams can then generate and manage API keys for dissemination to other implementing teams. Service accounts can be used to generate multiple API keys ensuring that implementing teams only use their own key. Keys managed in this way are more easily audited and help ensure that permissions are set correctly and remain stable. Individuals should be encouraged not to use their own API keys except for development and testing.

### Automated API Key Generation
API Keys can be generated via [NerdGraph](/docs/apis/nerdgraph/examples/use-nerdgraph-manage-license-keys-user-keys) allowing for fully automated on-demand API key provisioning. This could be used to automate generation of keys via a portal or service process flow. 


## Automation tools
We recommend using [Terraform](https://www.terraform.io) (or a derivative such as [Pulumi](https://www.pulumi.com)) to manage the provisioning of your New Relic resources. Tools like Terraform allow you to configure resources in code without having to concern yourself with which API's to call or how to maintain a record of what has been created. 

New Relic actively maintains our own [New Relic Terraform provider](https://registry.terraform.io/providers/newrelic/newrelic/latest/docs). Features and issues can be raised on the open source [Github repository](https://github.com/newrelic/terraform-provider-newrelic/issues).

### State management
When managing New Relic resources with Terraform it's important to keep a stable record of the terraform state. Ideally state should be securely stored in a [remote location](https://www.terraform.io/language/state/remote), be version controlled and leverage [state locking](https://www.terraform.io/language/state/locking) in order to ensure stability. 

### Dealing with large resource sets
Every resource configured in Terraform needs to be refreshed and evaluated to look for changes when new configurations are applied. As the size of configuration grows the list of resources to check against increases. Each check requires an API call and so large configurations may take some time to complete and may encounter API limits if too many requests are made in parallel. One approach is to reduce the number of resources managed within a single state, breaking down the configuration into parts. Also reducing the [parallelism of Terraform requests](https://www.terraform.io/cli/commands/apply#parallelism-n) can alleviate API limiting. 

### Take a modular approach
Modules are the main way to package and reuse resource configurations with Terraform and can be leveraged to package together any number of New Relic resources. Packaging like this allows for parameter driven deployments. For example, you may have a module that takes an application name and builds an overview dashboard, golden signal alerts and synthetic journey all in one operation.
 
Terraform modules can be [published](https://www.terraform.io/language/modules#published-modules) to remote registries allowing teams to share and consume resource packages developed by other teams.  This provides opportunities to implement standardization and roll out versio controlled changes and improvements easily.

### Automation workflows
Automation workflows are essential for scaling observability as code to teams and organizations. There are many CI/CD tools and services available that can drive [Terraform workflows](https://www.terraform.io/intro/core-workflow). These allow configuration changes to be discussed and approved whilst also providing an auditable trail of changes.

We recommend adopting a [Terraform workflow](https://www.terraform.io/intro/core-workflow) to enable teams to work together on New Relic configuration. One such workflow leverages the CI/CD capabilites of code versioning systems such as Github, Gitlab and Bitbucket to automatically plan and apply code using built in approval and review mechanisms

![Example Terraform workflow](./images/oac-tf-workflow.png "Simple Terraform workflow")
<figcaption>
  This diagram illustrates how a change is raised as a PR which is then approved and merged to main to trigger resource deployment.
</figcaption>

### Example workflows implementations
The following reference examples demonstrate how to setup a Terraform worfklow in a number of different systems:

- [Github Actions](https://github.com/newrelic-experimental/oma-nr-terraform-workflows/blob/main/github-action-example) - This example demonstrates how to use [Github actions](https://github.com/features/actions) together with AWS S3 backed state storage.
- [Gitlab Pipeline](https://github.com/newrelic-experimental/oma-nr-terraform-workflows/blob/main/gitlab-pipeline-example) - This example demonstrates hwo to use a [Gitlab pipeline](https://docs.gitlab.com/ee/user/infrastructure/iac/) together with Gitlab http state storage.
- [Bitbucket Pipeline](https://github.com/newrelic-experimental/oma-nr-terraform-workflows/blob/main/bitbucket-pipeline-example) - This example demonstrates using a [Bitbucket pipeline](https://bitbucket.org/product/features/pipelines) together with S3 backed state storage.


## Additional topics (title TBC)

### Detecting configuration drift
TBC

### Migrating existing resources
TBC
